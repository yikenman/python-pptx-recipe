name: Build from Upstream with Patch

on:
#   schedule:
#     - cron: '0 3 * * *' 
  workflow_dispatch:

env:
  UPSTREAM_REPO_OWNER: "pyodide"  
  UPSTREAM_REPO_NAME: "pyodide-recipes"  
  WORK_DIR: "upstream-dir"

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout controller repo (this repo)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch latest upstream tag
        id: fetch
        run: |
            tag=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -X POST -d '{"query":"query { repository(owner: \"${{ env.UPSTREAM_REPO_OWNER }}\", name: \"${{ env.UPSTREAM_REPO_NAME }}\") { refs(refPrefix: \"refs/tags/\", first: 1, orderBy: {field: TAG_COMMIT_DATE, direction: DESC}) { nodes { name }}}}"}' \
            https://api.github.com/graphql | jq -r '.data.repository.refs.nodes[0].name')
            echo "latest_tag=$tag" >> $GITHUB_OUTPUT

      - name: Check if tag has already been built
        id: check_tag
        run: |
          if git ls-remote --tags origin "refs/tags/${{ steps.fetch.outputs.latest_tag }}" | grep -q .; then
            echo "Tag already built. Skipping."
            echo "build_required=false" >> $GITHUB_OUTPUT
          else
            echo "build_required=true" >> $GITHUB_OUTPUT
          fi

      - name: Set up Python
        if: steps.check_tag.outputs.build_required == 'true'
        uses: actions/setup-python@v5
        with:
            python-version: '3.13'
        
      - name: Clone upstream repo at tag
        if: steps.check_tag.outputs.build_required == 'true'
        run: |
          git clone --recursive --branch ${{ steps.fetch.outputs.latest_tag }} https://github.com/${{ env.UPSTREAM_REPO_OWNER }}/${{ env.UPSTREAM_REPO_NAME }}.git ${{ env.WORK_DIR }}

      - name: Apply patch
        if: steps.check_tag.outputs.build_required == 'true'
        run: |
          cd ${{ env.WORK_DIR }}
          git config user.name "builder"
          git config user.email "builder@gh"
          for p in ../patches/*.patch; do
            echo "Applying patch $p"
            git apply "$p"
          done

      - name: Prepare env & Build recipes
        if: steps.check_tag.outputs.build_required == 'true'
        run: |
            cd ${{ env.WORK_DIR }}
            pip install ./pyodide-build
            python ./tools/install_and_patch_emscripten.py
            source emsdk/emsdk_env.sh
            pyodide build-recipes "python-pptx" --recipe-dir ./packages --install

      - name: Filter pyodide-lock.json and cleanup dist files
        run: |
          cd "${{ env.WORK_DIR }}/dist"

          TARGET="python-pptx"
          LOCK_FILE="pyodide-lock.json"

          jq -r --arg target "$TARGET" '
            def walk_deps($pkgs; $acc):
              if ($pkgs[$acc[-1]] | has("depends")) and ($pkgs[$acc[-1]].depends | length > 0)
              then
                reduce ($pkgs[$acc[-1]].depends[]) as $d (
                  $acc;
                  if $acc | index($d) then . else walk_deps($pkgs; . + [$d]) end
                )
              else $acc
              end;
            .packages as $pkgs |
            ($pkgs[$target]? | if . then walk_deps($pkgs; [$target]) else [] end) as $keep |
            .packages |= with_entries(select(.key as $k | $keep | index($k)))
          ' "$LOCK_FILE" > __filtered__.json && mv __filtered__.json "$LOCK_FILE"

          FILES=$(jq -r '.packages[].file_name' "$LOCK_FILE")
          FILES="$FILES pyodide-lock.json"

          for f in *; do
            if ! echo "$FILES" | grep -qxF "$f"; then
              echo "Deleting $f"
              rm -rf -- "$f"
            fi
          done
        shell: bash

      - name: Compress output
        if: steps.check_tag.outputs.build_required == 'true'
        run: |
          cd ${{ env.WORK_DIR }}/dist
          ls -la
          tar -czf ../../packages.tar.gz .

      - name: Upload Release
        if: steps.check_tag.outputs.build_required == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.fetch.outputs.latest_tag }}
          files: |
            output-${{ steps.fetch.outputs.latest_tag }}.tar.gz
            ${{ env.WORK_DIR }}/dist/*.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
